// ==UserScript==
// @name         Emoji Overlay & Live Auto-replace (Tampermonkey)
// @namespace    https://github.com/jordanalbiar/emoji-overlay
// @version      1.4.0
// @description  Live emoji replacement as you type: replace keywords like "smile" -> "ðŸ˜ƒ" in inputs, textareas and contenteditable fields (works more reliably on dynamic sites and chat/search inputs). Configurable mappings and overlay UI (Ctrl+Shift+E). Polling fallback included for hard-to-hook sites.
// @author       copilot
// @match        *://*/*
// @grant        none
// @run-at       document-end
// ==/UserScript==

/* Summary
 - This update makes replacements happen immediately as you type a mapped keyword (e.g. smile -> ðŸ˜ƒ),
   without needing to type a delimiter. It improves detection on dynamic sites (React etc.) by:
   - Listening to beforeinput/input/keydown/composition events at capture phase
   - Adding a short polling fallback to catch cases where sites intercept or shadow inputs
   - Handling inputs, textareas and contentEditable areas
 - You can toggle whether plain-word replacement is enabled in the overlay UI (Require :shortcode:)
*/

(function () {
  'use strict';

  // === Config & Storage ===
  const STORAGE_KEY = 'tmEmojiOverlayConfig_v1';

  function loadConfig() {
    const defaultConfig = {
      enabled: true,
      requireColons: false, // default now allows plain words (you can toggle in UI)
      mappings: {
        smile: 'ðŸ˜ƒ',
        grin: 'ðŸ˜',
        laugh: 'ðŸ˜„',
        joy: 'ðŸ˜‚',
        wink: 'ðŸ˜‰',
        heart: 'â¤ï¸',
        thumbs_up: 'ðŸ‘',
        clap: 'ðŸ‘',
        fire: 'ðŸ”¥',
        cry: 'ðŸ˜¢',
        sob: 'ðŸ˜­',
        thinking: 'ðŸ¤”',
        star: 'â­',
        party: 'ðŸ¥³',
        ok: 'ðŸ‘Œ',
        pray: 'ðŸ™',
        poop: 'ðŸ’©',
        rocket: 'ðŸš€',
        eyes: 'ðŸ‘€',
        kiss: 'ðŸ˜˜',
        blush: 'ðŸ˜Š',
        angry: 'ðŸ˜ ',
        scream: 'ðŸ˜±',
        cool: 'ðŸ˜Ž',
        sleeping: 'ðŸ˜´',
        sunflower: 'ðŸŒ»',
        grinning: 'ðŸ˜€',
        smiley: 'ðŸ˜ƒ',
        smile: 'ðŸ˜„',
        grin: 'ðŸ˜',
        laughing: 'ðŸ˜†',
        sweat_smile: 'ðŸ˜…',
        joy: 'ðŸ˜‚',
        rofl: 'ðŸ¤£',
        blush: 'ðŸ˜Š',
        innocent: 'ðŸ˜‡',
        slight_slile: 'ðŸ™‚',
        upside_down: 'ðŸ™ƒ',
        wink: 'ðŸ˜‰',
        relieved: 'ðŸ˜Œ',
        heart_eyes: 'ðŸ˜',
        smiling_face_with_3_hearts: 'ðŸ¥°',
        kissing_heart: 'ðŸ˜˜',
        kissing: 'ðŸ˜—',
        kissing_smiling_eyes: 'ðŸ˜™',
        kissing_closed_eyes: 'ðŸ˜š',
        yum: 'ðŸ˜‹',
        stuck_out_tongue: 'ðŸ˜›',
        stuck_out_tongue_winking_eye: 'ðŸ˜œ',
        zany_face: 'ðŸ¤ª',
        stuck_out_tongue_closed_eyes: 'ðŸ˜',
        money_mouth: 'ðŸ¤‘',
        hugs: 'ðŸ¤—',
        face_with_hand_over_mouth: 'ðŸ¤­',
        shushing_face: 'ðŸ¤«',
        thinking: 'ðŸ¤”',
        zipper_mouth: 'ðŸ¤',
        face_with_raised_eyebrow: 'ðŸ¤¨',

        dog: 'ðŸ¶',
        cat: 'ðŸ±',
        mouse: 'ðŸ­',
        hamster: 'ðŸ¹',
        rabbit: 'ðŸ°',
        fox: 'ðŸ¦Š',
        bear: 'ðŸ»',
        panda_face: 'ðŸ¼',
        koala: 'ðŸ¨',
        tiger: 'ðŸ¯',
        lion: 'ðŸ¦',
        cow: 'ðŸ®',
        pig: 'ðŸ·',
        frog: 'ðŸ¸',
        monkey_face: 'ðŸµ',
        chicken: 'ðŸ”',
        unicorn: 'ðŸ¦„',
        horse: 'ðŸ´',
        zebra: 'ðŸ¦“',
        snake: 'ðŸ',
        turtle: 'ðŸ¢',
        lizard: 'ðŸ¦Ž',
        octopus: 'ðŸ™',
        squid: 'ðŸ¦‘',
        fish: 'ðŸŸ',
        dolphin: 'ðŸ¬',
        butterfly: 'ðŸ¦‹',
        lady_beetle: 'ðŸž',
        ant: 'ðŸœ',
        duck: 'ðŸ¦†',
        deciduous_tree: 'ðŸŒ³',
        cherry_blossom: 'ðŸŒ¸',
        sunflower: 'ðŸŒ»',
        blossom: 'ðŸŒ¼',
        hibiscus: 'ðŸŒº',
        rose: 'ðŸŒ¹',
        cactus: 'ðŸŒµ',
        palm_tree: 'ðŸŒ´',
        four_leaf_clover: 'ðŸ€',
        fallen_leaf: 'ðŸ‚',
        maple_leaf: 'ðŸ',

        green_apple: 'ðŸ',
        apple: 'ðŸŽ',
        pear: 'ðŸ',
        tangerine: 'ðŸŠ',
        lemon: 'ðŸ‹',
        banana: 'ðŸŒ',
        watermelon: 'ðŸ‰',
        grapes: 'ðŸ‡',
        strawberry: 'ðŸ“',
        melon: 'ðŸˆ',
        cherries: 'ðŸ’',
        peach: 'ðŸ‘',
        pineapple: 'ðŸ',
        mango: 'ðŸ¥­',
        coconut: 'ðŸ¥¥',
        kiwi: 'ðŸ¥',
        tomato: 'ðŸ…',
        avocado: 'ðŸ¥‘',
        broccoli: 'ðŸ¥¦',
        leafy_green: 'ðŸ¥¬',
        cucumber: 'ðŸ¥’',
        corn: 'ðŸŒ½',
        carrot: 'ðŸ¥•',
        potato: 'ðŸ¥”',
        sweet_potato: 'ðŸ ',
        bagel: 'ðŸ¥¯',
        baguette_bread: 'ðŸ¥–',
        bread: 'ðŸž',
        croissant: 'ðŸ¥',
        pancakes: 'ðŸ¥ž',
        waffle: 'ðŸ§‡',
        cheese: 'ðŸ§€',
        meat_on_bone: 'ðŸ–',
        poultry_leg: 'ðŸ—',
        hamburger: 'ðŸ”',
        fries: 'ðŸŸ',
        pizza: 'ðŸ•',
        hotdog: 'ðŸŒ­',
        taco: 'ðŸŒ®',
        burrito: 'ðŸŒ¯',
        stuffed_flatbread: 'ðŸ¥™',
        sushi: 'ðŸ£',
        bento: 'ðŸ±',
        curry: 'ðŸ›',
        ramen: 'ðŸœ',
        stew: 'ðŸ²',
        green_salad: 'ðŸ¥—',
        popcorn: 'ðŸ¿',
        salt: 'ðŸ§‚',
        doughnut: 'ðŸ©',
        cookie: 'ðŸª',
        birthday: 'ðŸŽ‚',
        cake: 'ðŸ°',
        cupcake: 'ðŸ§',
        chocolate_bar: 'ðŸ«',
        candy: 'ðŸ¬',
        lollipop: 'ðŸ­',
        custard: 'ðŸ®',
        honey_pot: 'ðŸ¯',
        coffee: 'â˜•',
        tea: 'ðŸµ',
        cup_with_straw: 'ðŸ¥¤',
        beer: 'ðŸº',
        beers: 'ðŸ»',
        clinking_glasses: 'ðŸ¥‚',
        wine_glass: 'ðŸ·',
        cocktail: 'ðŸ¸',
        tumbler_glass: 'ðŸ¥ƒ',
        milk_glass: 'ðŸ¥›',

        soccer: 'âš½',
        basketball: 'ðŸ€',
        football: 'ðŸˆ',
        baseball: 'âš¾',
        tennis: 'ðŸŽ¾',
        volleyball: 'ðŸ',
        rugby_football: 'ðŸ‰',
        ping_pong: 'ðŸ“',
        badminton: 'ðŸ¸',
        goal_net: 'ðŸ¥…',
        ice_hockey: 'ðŸ’',
        field_hockey: 'ðŸ‘',
        lacrosse: 'ðŸ¥',
        cricket_bat_and_ball: 'ðŸ',
        golf: 'â›³',
        bow_and_arrow: 'ðŸ¹',
        fishing_pole_and_fish: 'ðŸŽ£',
        boxing_glove: 'ðŸ¥Š',
        martial_arts_uniform: 'ðŸ¥‹',
        running_shirt_with_sash: 'ðŸŽ½',
        sports_medal: 'ðŸ…',
        medal_military: 'ðŸŽ–ï¸',
        first_place_medal: 'ðŸ¥‡',
        second_place_medal: 'ðŸ¥ˆ',
        third_place_medal: 'ðŸ¥‰',
        trophy: 'ðŸ†',
        rosette: 'ðŸµï¸',
        reminder_ribbon: 'ðŸŽ—ï¸',
        ticket: 'ðŸŽ«',
        tickets: 'ðŸŽŸï¸',
        circus_tent: 'ðŸŽª',
        juggling: 'ðŸ¤¹',
        performing_arts: 'ðŸŽ­',
        art: 'ðŸŽ¨',
        clapper: 'ðŸŽ¬',
        microphone: 'ðŸŽ¤',
        headphones: 'ðŸŽ§',
        saxophone: 'ðŸŽ·',
        guitar: 'ðŸŽ¸',
        musical_keyboard: 'ðŸŽ¹',
        trumpet: 'ðŸŽº',
        violin: 'ðŸŽ»',
        drum: 'ðŸ¥',
        dart: 'ðŸŽ¯',
        bowling: 'ðŸŽ³',
        video_game: 'ðŸŽ®',
        joystick: 'ðŸ•¹ï¸',
        slot_machine: 'ðŸŽ°',
        game_die: 'ðŸŽ²',
        jigsaw: 'ðŸ§©',
        chess_pawn: 'â™Ÿï¸',
        flower_playing_cards: 'ðŸŽ´',
        black_joker: 'ðŸƒ',
        mahjong: 'ðŸ€„',

        car: 'ðŸš—',
        taxi: 'ðŸš•',
        blue_car: 'ðŸš™',
        bus: 'ðŸšŒ',
        trolleybus: 'ðŸšŽ',
        racing_car: 'ðŸŽï¸',
        police_car: 'ðŸš“',
        ambulance: 'ðŸš‘',
        fire_engine: 'ðŸš’',
        minibus: 'ðŸš',
        truck: 'ðŸšš',
        articulated_lorry: 'ðŸš›',
        tractor: 'ðŸšœ',
        kick_scooter: 'ðŸ›´',
        bike: 'ðŸš²',
        motor_scooter: 'ðŸ›µ',
        motorcycle: 'ðŸï¸',
        rotating_light: 'ðŸš¨',
        oncoming_police_car: 'ðŸš”',
        oncoming_bus: 'ðŸš',
        oncoming_automobile: 'ðŸš˜',
        oncoming_taxi: 'ðŸš–',
        aerial_tramway: 'ðŸš¡',
        mountain_cableway: 'ðŸš ',
        suspension_railway: 'ðŸšŸ',
        railway_car: 'ðŸšƒ',
        train: 'ðŸš‹',
        mountain_railway: 'ðŸšž',
        monorail: 'ðŸš',
        bullettrain_side: 'ðŸš„',
        bullettrain_front: 'ðŸš…',
        light_rail: 'ðŸšˆ',
        steam_locomotive: 'ðŸš‚',
        train2: 'ðŸš†',
        metro: 'ðŸš‡',
        tram: 'ðŸšŠ',
        station: 'ðŸš‰',
        airplane: 'âœˆï¸',
        airplane_departure: 'ðŸ›«',
        airplane_arriving: 'ðŸ›¬',
        small_airplane: 'ðŸ›©ï¸',
        seat: 'ðŸ’º',
        helicopter: 'ðŸš',
        artificial_satellite: 'ðŸ›°ï¸',
        rocket: 'ðŸš€',
        flying_saucer: 'ðŸ›¸',
        canoe: 'ðŸ›¶',
        boat: 'â›µ',
        speedboat: 'ðŸš¤',
        motor_boat: 'ðŸ›¥ï¸',
        passenger_ship: 'ðŸ›³ï¸',
        ship: 'ðŸš¢',
        anchor: 'âš“',
        ferry: 'â›´ï¸',
        beach_umbrella: 'ðŸ–ï¸',
        volcano: 'ðŸŒ‹',
        mount_fuji: 'ðŸ—»',
        mountain_snow: 'ðŸ”ï¸',
        camping: 'ðŸ•ï¸',
        desert: 'ðŸœï¸',
        desert_island: 'ðŸï¸',
        national_park: 'ðŸžï¸',
        stadium: 'ðŸŸï¸',
        classical_building: 'ðŸ›ï¸',
        building_construction: 'ðŸ—ï¸',
        houses: 'ðŸ˜ï¸',
        cityscape: 'ðŸ™ï¸',
        house_abandoned: 'ðŸšï¸',
        house: 'ðŸ ',
        house_with_garden: 'ðŸ¡',
        office: 'ðŸ¢',
        post_office: 'ðŸ£',
        european_post_office: 'ðŸ¤',
        hospital: 'ðŸ¥',
        bank: 'ðŸ¦',
        hotel: 'ðŸ¨',
        love_hotel: 'ðŸ©',
        convenience_store: 'ðŸª',
        school: 'ðŸ«',
        department_store: 'ðŸ¬',
        factory: 'ðŸ­',
        japanese_castle: 'ðŸ¯',
        european_castle: 'ðŸ°',
        wedding: 'ðŸ’’',
        tokyo_tower: 'ðŸ—¼',
        statue_of_liberty: 'ðŸ—½',
        map_of_japan: 'ðŸ—¾',
        foggy: 'ðŸŒ',
        night_with_stars: 'ðŸŒƒ',
        sunrise_over_mountains: 'ðŸŒ„',
        sunrise: 'ðŸŒ…',
        city_sunrise: 'ðŸŒ†',
        city_sunset: 'ðŸŒ‡',
        bridge_at_night: 'ðŸŒ‰',
        milky_way: 'ðŸŒŒ',

        lock: 'ðŸ”’',
        unlock: 'ðŸ”“',
        lock_with_ink_pen: 'ðŸ”',
        closed_lock_with_key: 'ðŸ”',
        key: 'ðŸ”‘',
        old_key: 'ðŸ—ï¸',
        hammer: 'ðŸ”¨',
        axe: 'ðŸª“',
        pick: 'â›ï¸',
        hammer_and_pick: 'âš’ï¸',
        hammer_and_wrench: 'ðŸ› ï¸',
        dagger: 'ðŸ—¡ï¸',
        crossed_swords: 'âš”ï¸',
        gun: 'ðŸ”«',
        shield: 'ðŸ›¡ï¸',
        wrench: 'ðŸ”§',
        nut_and_bolt: 'ðŸ”©',
        gear: 'âš™ï¸',
        clamp: 'ðŸ—œï¸',
        probing_cane: 'ðŸ¦¯',
        link: 'ðŸ”—',
        chains: 'â›“ï¸',
        hook: 'ðŸª',
        toolbox: 'ðŸ§°',
        magnet: 'ðŸ§²',
        ladder: 'ðŸªœ',
        alembic: 'âš—ï¸',
        test_tube: 'ðŸ§ª',
        petri_dish: 'ðŸ§«',
        dna: 'ðŸ§¬',
        microscope: 'ðŸ”¬',
        telescope: 'ðŸ”­',
        satellite: 'ðŸ“¡',
        syringe: 'ðŸ’‰',
        drop_of_blood: 'ðŸ©¸',
        pill: 'ðŸ’Š',
        adhesive_bandage: 'ðŸ©¹',
        stethoscope: 'ðŸ©º',
        door: 'ðŸšª',
        elevator: 'ðŸ›—',
        mirror: 'ðŸªž',
        window: 'ðŸªŸ',
        bed: 'ðŸ›ï¸',
        couch_and_lamp: 'ðŸ›‹ï¸',
        chair: 'ðŸª‘',
        toilet: 'ðŸš½',
        shower: 'ðŸš¿',
        bathtub: 'ðŸ›',
        plunger: 'ðŸª ',
        smoking: 'ðŸš¬',
        coffin: 'âš°ï¸',
        funeral_urn: 'âš±ï¸',
        moyai: 'ðŸ—¿',
        shopping: 'ðŸ›ï¸',
        shopping_cart: 'ðŸ›’',
        gift: 'ðŸŽ',
        balloon: 'ðŸŽˆ',
        flags: 'ðŸŽ',
        ribbon: 'ðŸŽ€',
        confetti_ball: 'ðŸŽŠ',
        tada: 'ðŸŽ‰',
        dolls: 'ðŸŽŽ',
        izakaya_lantern: 'ðŸ®',
        diya_lamp: 'ðŸª”',
        email: 'âœ‰ï¸',
        package: 'ðŸ“¦',
        postbox: 'ðŸ“®',
        postal_horn: 'ðŸ“¯',
        scroll: 'ðŸ“œ',
        page_with_curl: 'ðŸ“ƒ',
        page_facing_up: 'ðŸ“„',
        date: 'ðŸ“…',
        calendar: 'ðŸ“†',
        card_index: 'ðŸ“‡',
        clipboard: 'ðŸ“‹',
        file_folder: 'ðŸ“',
        open_file_folder: 'ðŸ“‚',
        card_index_dividers: 'ðŸ—‚ï¸',
        file_cabinet: 'ðŸ—ƒï¸',
        filing_cabinet: 'ðŸ—„ï¸',
        bookmark_tabs: 'ðŸ“‘',
        label: 'ðŸ·ï¸',
        bar_chart: 'ðŸ“Š',
        chart_with_upwards_trend: 'ðŸ“ˆ',
        chart_with_downwards_trend: 'ðŸ“‰',
        pushpin: 'ðŸ“Œ',
        round_pushpin: 'ðŸ“',
        paperclip: 'ðŸ“Ž',
        paperclips: 'ðŸ–‡ï¸',
        triangular_ruler: 'ðŸ“',
        straight_ruler: 'ðŸ“',
        abacus: 'ðŸ§®',
        closed_book: 'ðŸ“•',
        book: 'ðŸ“–',
        green_book: 'ðŸ“—',
        blue_book: 'ðŸ“˜',
        orange_book: 'ðŸ“™',
        books: 'ðŸ“š',
        notebook: 'ðŸ““',
        ledger: 'ðŸ“’',
        newspaper_roll: 'ðŸ—žï¸',
        bookmark: 'ðŸ”–',
        camera: 'ðŸ“·',
        camera_flash: 'ðŸ“¸',
        video_camera: 'ðŸ“¹',
        vhs: 'ðŸ“¼',
        tv: 'ðŸ“º',
        radio: 'ðŸ“»',
        studio_microphone: 'ðŸŽ™ï¸',
        banjo: 'ðŸª•',
        drum: 'ðŸ¥',
        saxophone: 'ðŸŽ·',
        yo_yo: 'ðŸª€',
        teddy_bear: 'ðŸ§¸',
        nesting_dolls: 'ðŸª†',
        piÃ±ata: 'ðŸª…',
        jigsaw: 'ðŸ§©',
        crystal_ball: 'ðŸ”®',
        nazar_amulet: 'ðŸ§¿',
        magic_wand: 'ðŸª„',

        teddy_bear_dup: 'ðŸ§¸',
        shopping_dup: 'ðŸ›ï¸',
        shopping_cart_dup: 'ðŸ›’',

        heart: 'â¤ï¸',
        yellow_heart: 'ðŸ’›',
        green_heart: 'ðŸ’š',
        blue_heart: 'ðŸ’™',
        purple_heart: 'ðŸ’œ',
        black_heart: 'ðŸ–¤',
        white_heart: 'ðŸ¤',
        brown_heart: 'ðŸ¤Ž',
        broken_heart: 'ðŸ’”',
        heavy_heart_exclamation: 'â£ï¸',
        two_hearts: 'ðŸ’•',
        revolving_hearts: 'ðŸ’ž',
        heartbeat: 'ðŸ’“',
        heartpulse: 'ðŸ’—',
        sparkling_heart: 'ðŸ’–',
        cupid: 'ðŸ’˜',
        gift_heart: 'ðŸ’',
        heart_decoration: 'ðŸ’Ÿ',
        peace_symbol: 'â˜®ï¸',
        latin_cross: 'âœï¸',
        star_and_crescent: 'â˜ªï¸',
        om: 'ðŸ•‰ï¸',
        wheel_of_dharma: 'â˜¸ï¸',
        star_of_david: 'âœ¡ï¸',
        six_pointed_star: 'ðŸ”¯',
        menorah: 'ðŸ•Ž',
        yin_yang: 'â˜¯ï¸',
        orthodox_cross: 'â˜¦ï¸',
        place_of_worship: 'ðŸ›',
        ophiuchus: 'â›Ž',
        aries: 'â™ˆ',
        taurus: 'â™‰',
        gemini: 'â™Š',
        cancer: 'â™‹',
        leo: 'â™Œ',
        virgo: 'â™',
        libra: 'â™Ž',
        scorpio: 'â™',
        sagittarius: 'â™',
        capricorn: 'â™‘',
        aquarius: 'â™’',
        pisces: 'â™“',
        twisted_rightwards_arrows: 'ðŸ”€',
        repeat: 'ðŸ”',
        repeat_one: 'ðŸ”‚',
        arrow_forward: 'â–¶ï¸',
        fast_forward: 'â©',
        next_track_button: 'â­ï¸',
        play_or_pause_button: 'â¯ï¸',
        arrow_backward: 'â—€ï¸',
        rewind: 'âª',
        previous_track_button: 'â®ï¸',
        arrow_up_small: 'ðŸ”¼',
        arrow_double_up: 'â«',
        arrow_down_small: 'ðŸ”½',
        arrow_double_down: 'â¬',
        cinema: 'ðŸŽ¦',
        low_brightness: 'ðŸ”…',
        high_brightness: 'ðŸ”†',
        signal_strength: 'ðŸ“¶',
        vibration_mode: 'ðŸ“³',
        mobile_phone_off: 'ðŸ“´',
        recycle: 'â™»ï¸',
        ok: 'ðŸ†—',
        cool: 'ðŸ†’',
        new: 'ðŸ†•',
        up: 'ðŸ†™',
        free: 'ðŸ†“',
        abc: 'ðŸ”¤',
        abcd: 'ðŸ”¡',
        capital_abcd: 'ðŸ” ',
        symbols: 'ðŸ”£',
        a: 'ðŸ…°ï¸',
        b: 'ðŸ…±ï¸',
        ab: 'ðŸ†Ž',
        o: 'ðŸ…¾ï¸',
        arrows_counterclockwise: 'ðŸ”„',
        arrows_clockwise: 'ðŸ”ƒ',
        musical_note: 'ðŸŽµ',
        notes: 'ðŸŽ¶',
        heavy_plus_sign: 'âž•',
        heavy_minus_sign: 'âž–',
        heavy_division_sign: 'âž—',
        heavy_multiplication_x: 'âœ–ï¸',
        infinity: 'â™¾ï¸',
        question: 'â“',
        grey_question: 'â”',
        grey_exclamation: 'â•',
        exclamation: 'â—',
        interrobang: 'â‰ï¸',
        currency_exchange: 'ðŸ’±',
        heavy_dollar_sign: 'ðŸ’²',
        medical_symbol: 'âš•ï¸',
        fleur_de_lis: 'âšœï¸',
        trident: 'ðŸ”±',
        name_badge: 'ðŸ“›',
        beginner: 'ðŸ”°',
        o_circle: 'â­•',
        white_check_mark: 'âœ…',
        ballot_box_with_check: 'â˜‘ï¸',
        heavy_check_mark: 'âœ”ï¸',
        x: 'âŒ',
        negative_squared_cross_mark: 'âŽ',
        curly_loop: 'âž°',
        loop: 'âž¿',
        part_alternation_mark: 'ã€½ï¸',
        end: 'ðŸ”š',
        on: 'ðŸ”›',
        soon: 'ðŸ”œ',
        top: 'ðŸ”',
        koko: 'ðŸˆ',
        vs: 'ðŸ†š',
        accept: 'ðŸ‰‘',

        flag_us: 'ðŸ‡ºðŸ‡¸',
        flag_ca: 'ðŸ‡¨ðŸ‡¦',
        flag_gb: 'ðŸ‡¬ðŸ‡§',
        flag_au: 'ðŸ‡¦ðŸ‡º',
        flag_in: 'ðŸ‡®ðŸ‡³',
        flag_jp: 'ðŸ‡¯ðŸ‡µ',
        flag_kr: 'ðŸ‡°ðŸ‡·',
        flag_cn: 'ðŸ‡¨ðŸ‡³',
        flag_de: 'ðŸ‡©ðŸ‡ª',
        flag_fr: 'ðŸ‡«ðŸ‡·',
        flag_es: 'ðŸ‡ªðŸ‡¸',
        flag_it: 'ðŸ‡®ðŸ‡¹',
        flag_br: 'ðŸ‡§ðŸ‡·',
        flag_ru: 'ðŸ‡·ðŸ‡º',
        flag_mx: 'ðŸ‡²ðŸ‡½',
        flag_sa: 'ðŸ‡¸ðŸ‡¦',
        flag_za: 'ðŸ‡¿ðŸ‡¦',
        flag_ae: 'ðŸ‡¦ðŸ‡ª',
        flag_ar: 'ðŸ‡¦ðŸ‡·',
        flag_ng: 'ðŸ‡³ðŸ‡¬',
        flag_eg: 'ðŸ‡ªðŸ‡¬',
        flag_tr: 'ðŸ‡¹ðŸ‡·',
        flag_il: 'ðŸ‡®ðŸ‡±',
        flag_sg: 'ðŸ‡¸ðŸ‡¬',
        flag_nz: 'ðŸ‡³ðŸ‡¿',
        flag_id: 'ðŸ‡®ðŸ‡©',
        flag_ph: 'ðŸ‡µðŸ‡­',
        flag_pk: 'ðŸ‡µðŸ‡°',
        flag_th: 'ðŸ‡¹ðŸ‡­',
        flag_vn: 'ðŸ‡»ðŸ‡³',
        flag_my: 'ðŸ‡²ðŸ‡¾',
        flag_bd: 'ðŸ‡§ðŸ‡©',
        flag_pl: 'ðŸ‡µðŸ‡±',
        flag_no: 'ðŸ‡³ðŸ‡´',
        flag_se: 'ðŸ‡¸ðŸ‡ª',
        flag_dk: 'ðŸ‡©ðŸ‡°',
        flag_fi: 'ðŸ‡«ðŸ‡®',
        flag_nl: 'ðŸ‡³ðŸ‡±',
        flag_be: 'ðŸ‡§ðŸ‡ª',
        flag_at: 'ðŸ‡¦ðŸ‡¹',
        flag_ch: 'ðŸ‡¨ðŸ‡­',
        flag_pt: 'ðŸ‡µðŸ‡¹',
        flag_gr: 'ðŸ‡¬ðŸ‡·',
        flag_hu: 'ðŸ‡­ðŸ‡º',
        flag_cz: 'ðŸ‡¨ðŸ‡¿',
        flag_ro: 'ðŸ‡·ðŸ‡´',
        flag_sk: 'ðŸ‡¸ðŸ‡°',
        flag_bg: 'ðŸ‡§ðŸ‡¬',
        flag_ir: 'ðŸ‡®ðŸ‡·',
        flag_iq: 'ðŸ‡®ðŸ‡¶',
        flag_np: 'ðŸ‡³ðŸ‡µ',
        flag_af: 'ðŸ‡¦ðŸ‡«',
        flag_lk: 'ðŸ‡±ðŸ‡°',
        flag_bh: 'ðŸ‡§ðŸ‡­',
        flag_jo: 'ðŸ‡¯ðŸ‡´',
        flag_qa: 'ðŸ‡¶ðŸ‡¦',
        flag_om: 'ðŸ‡´ðŸ‡²',
        flag_kw: 'ðŸ‡°ðŸ‡¼',
        flag_ye: 'ðŸ‡¾ðŸ‡ª',
        flag_ma: 'ðŸ‡²ðŸ‡¦',
        flag_dz: 'ðŸ‡©ðŸ‡¿',
        flag_tn: 'ðŸ‡¹ðŸ‡³',
        flag_ly: 'ðŸ‡±ðŸ‡¾',
        rainbow_flag: 'ðŸ³ï¸â€ðŸŒˆ',
        transgender_flag: 'ðŸ³ï¸â€âš§ï¸',
        black_flag: 'ðŸ´',
        checkered_flag: 'ðŸ',
        triangular_flag_on_post: 'ðŸš©',
        white_flag: 'ðŸ³ï¸',
        united_nations: 'ðŸ‡ºðŸ‡³',

        cherry_blossom_aesthetic: 'ðŸŒ¸',
        crescent_moon: 'ðŸŒ™',
        sparkles: 'âœ¨',
        glowing_star: 'ðŸŒŸ',
        rainbow: 'ðŸŒˆ',
        dizzy: 'ðŸ’«',
        leaves: 'ðŸƒ',
        hibiscus_aesthetic: 'ðŸŒº',
        tulip: 'ðŸŒ·',
        fallen_leaf_dup: 'ðŸ‚',
        milky_way: 'ðŸŒŒ',
        wind_chime: 'ðŸŽ',
        two_hearts: 'ðŸ’•',
        musical_notes: 'ðŸŽ¶',
        sunflower_aesthetic: 'ðŸŒ»'
}
    };
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        return Object.assign({}, defaultConfig, JSON.parse(stored));
      }
    } catch (e) {
      console.warn('EmojiOverlay: load failed, using defaults.', e);
    }
    return defaultConfig;
  }

  function saveConfig(cfg) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg));
    } catch (e) {
      console.warn('EmojiOverlay: save failed', e);
    }
  }

  let config = loadConfig();

  // === Utility ===
  function triggerInputEvent(el) {
    try {
      const ev = new Event('input', { bubbles: true, cancelable: true });
      el.dispatchEvent(ev);
    } catch (e) {
      // ignore
    }
  }

  function isTextInput(el) {
    if (!el) return false;
    const t = el.tagName;
    if (!t) return false;
    return (t === 'INPUT' && /^(?:text|search|url|tel|email|password)$/i.test(el.type || 'text')) || t === 'TEXTAREA';
  }

  function isContentEditable(el) {
    return !!(el && el.isContentEditable);
  }

  // sanitize mapping key to canonical form
  function canonicalKey(k) {
    return k.trim().toLowerCase().replace(/\s+/g, '_');
  }

  // === Core Replacement Logic ===

  // Replace inside inputs/textareas (works for controlled components when we set value + dispatch input)
  function replaceInInput(el) {
    if (!config.enabled) return false;
    if (!el) return false;
    try {
      const val = el.value;
      const caret = el.selectionStart;
      if (caret == null) return false;

      const left = val.slice(0, caret);

      // If colon style is enabled, try :shortcode: first.
      if (config.requireColons) {
        const colonMatch = left.match(/:([a-z0-9_\-\+]+):$/i);
        if (colonMatch && config.mappings.hasOwnProperty(colonMatch[1])) {
          const key = colonMatch[1];
          const emoji = config.mappings[key];
          const startIdx = caret - colonMatch[0].length;
          const newVal = val.slice(0, startIdx) + emoji + val.slice(caret);
          el.value = newVal;
          const newPos = startIdx + emoji.length;
          el.setSelectionRange(newPos, newPos);
          triggerInputEvent(el);
          return true;
        }
        return false;
      }

      // Plain-word replacement mode: replace when the sequence of characters immediately before caret
      // forms a mapped keyword AND the character before the keyword (if any) is a non-word boundary.
      // Only replace when caret is right after the keyword (i.e., user typed the last letter).
      const match = left.match(/(^|[^a-z0-9_\-+])([a-z0-9_\-+]+)$/i);
      if (match) {
        const key = match[2].toLowerCase();
        if (config.mappings.hasOwnProperty(key)) {
          const emoji = config.mappings[key];
          const startIdx = caret - key.length;
          // ensure we don't eat preceding char: keep match[1] prefix
          const newVal = val.slice(0, startIdx) + emoji + val.slice(caret);
          el.value = newVal;
          const newPos = startIdx + emoji.length;
          el.setSelectionRange(newPos, newPos);
          triggerInputEvent(el);
          return true;
        }
      }
    } catch (e) {
      console.warn('EmojiOverlay: replaceInInput error', e);
    }
    return false;
  }

  // Replace inside contenteditable
  function replaceInContentEditable() {
    if (!config.enabled) return false;
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return false;
    const range = sel.getRangeAt(0);
    if (!range.collapsed) return false;

    // Get up to 128 chars before caret for context
    const maxBack = 128;
    const probeRange = range.cloneRange();
    let moved = 0;

    // Walk backwards char-by-char through text nodes to build 'before' string
    function getTextBefore(range, limit) {
      const r = range.cloneRange();
      let start = r.startContainer;
      let startOffset = r.startOffset;

      // We'll attempt to move the start backwards by characters.
      let text = '';
      let charsLeft = limit;
      let node = start;
      let offset = startOffset;

      // Helper to move to previous text node and set offset to its length
      function prevTextNode(n) {
        // Depth-first previous node search
        function prev(n) {
          if (!n) return null;
          if (n.previousSibling) {
            n = n.previousSibling;
            // go to deepest child
            while (n && n.lastChild) n = n.lastChild;
            return n;
          }
          return n.parentNode;
        }
        let p = prev(n);
        while (p && p.nodeType !== Node.TEXT_NODE) {
          p = prev(p);
        }
        return p;
      }

      let cur = node;
      let off = offset;
      // If current node is element, try previous text node
      if (cur.nodeType !== Node.TEXT_NODE) {
        cur = prevTextNode(cur);
        off = cur ? cur.textContent.length : 0;
      }

      while (cur && charsLeft > 0) {
        const take = Math.min(off, charsLeft);
        if (take > 0) {
          text = cur.textContent.slice(off - take, off) + text;
          charsLeft -= take;
        }
        if (charsLeft <= 0) break;
        cur = prevTextNode(cur);
        off = cur ? cur.textContent.length : 0;
      }
      return text;
    }

    const before = getTextBefore(range, maxBack);

    // Handle colon mode first
    if (config.requireColons) {
      const colonMatch = before.match(/:([a-z0-9_\-\+]+):$/i);
      if (colonMatch && config.mappings.hasOwnProperty(colonMatch[1])) {
        const key = colonMatch[1];
        const emoji = config.mappings[key];
        // Replace the matched portion by moving a new range and inserting emoji
        return replaceRangeText(range, colonMatch[0].length, emoji);
      }
      return false;
    }

    // Plain-word mode
    const wordMatch = before.match(/([a-z0-9_\-\+]+)$/i);
    if (wordMatch && config.mappings.hasOwnProperty(wordMatch[1].toLowerCase())) {
      const key = wordMatch[1].toLowerCase();
      const emoji = config.mappings[key];
      return replaceRangeText(range, wordMatch[0].length, emoji);
    }

    return false;
  }

  // Replace 'length' characters immediately before the provided collapsed range with 'text'
  function replaceRangeText(collapsedRange, charsBefore, text) {
    try {
      // Build a start position charsBefore chars back from collapsedRange.start
      const startRange = collapsedRange.cloneRange();
      // We'll move start backwards by traversing text nodes
      let remaining = charsBefore;
      let node = startRange.startContainer;
      let offset = startRange.startOffset;

      function prevTextNode(n) {
        function prev(n) {
          if (!n) return null;
          if (n.previousSibling) {
            n = n.previousSibling;
            while (n && n.lastChild) n = n.lastChild;
            return n;
          }
          return n.parentNode;
        }
        let p = prev(n);
        while (p && p.nodeType !== Node.TEXT_NODE) p = prev(p);
        return p;
      }

      // If starting in element, find last text node before offset
      if (node.nodeType !== Node.TEXT_NODE) {
        // find child at offset-1 and then its deepest rightmost text node
        let cur = node.childNodes[offset - 1];
        while (cur && cur.nodeType !== Node.TEXT_NODE && cur.lastChild) cur = cur.lastChild;
        node = cur || prevTextNode(node);
        offset = node ? node.textContent.length : 0;
      }

      while (remaining > 0 && node) {
        const take = Math.min(offset, remaining);
        remaining -= take;
        offset -= take;
        if (remaining <= 0) break;
        node = prevTextNode(node);
        offset = node ? node.textContent.length : 0;
      }

      if (!node) return false;
      const startNode = node;
      const startOffset = offset;

      const replacementRange = document.createRange();
      replacementRange.setStart(startNode, startOffset);
      replacementRange.setEnd(collapsedRange.startContainer, collapsedRange.startOffset);
      replacementRange.deleteContents();
      const textNode = document.createTextNode(text);
      replacementRange.insertNode(textNode);

      // Place caret after inserted node
      const sel = window.getSelection();
      sel.removeAllRanges();
      const newRange = document.createRange();
      newRange.setStartAfter(textNode);
      newRange.collapse(true);
      sel.addRange(newRange);
      return true;
    } catch (e) {
      console.warn('EmojiOverlay: replaceRangeText failed', e);
      return false;
    }
  }

  // === Event Handling & Robust Hooks ===

  // Primary handler, called from many events
  function tryReplaceActive() {
    const active = document.activeElement;
    if (!active) return false;
    if (isTextInput(active)) {
      return replaceInInput(active);
    } else if (isContentEditable(active)) {
      return replaceInContentEditable();
    }
    return false;
  }

  // Capture-phase listeners to be able to run before site handlers sometimes
  document.addEventListener('beforeinput', (e) => {
    // don't act during composition (IME)
    if (e.isComposing) return;
    // run on capture
    tryReplaceActive();
  }, true);

  document.addEventListener('input', (e) => {
    if (e.isComposing) return;
    tryReplaceActive();
  }, true);

  document.addEventListener('keydown', (e) => {
    // handle normal typing keys (letters, numbers, punctuation)
    // allow composition and modifier combos to pass
    if (e.metaKey || e.ctrlKey || e.altKey) return;
    // attempt replacement after the key (we cannot inspect next value here reliably), but schedule microtask
    requestAnimationFrame(() => {
      tryReplaceActive();
    });
  }, true);

  // compositionend: IME input finished
  document.addEventListener('compositionend', (e) => {
    setTimeout(() => tryReplaceActive(), 0);
  }, true);

  // fallback polling for sites that trap events or use shadow DOM heavily
  let lastChecked = { el: null, val: null, caret: null };
  setInterval(() => {
    const active = document.activeElement;
    if (!active) {
      lastChecked = { el: null, val: null, caret: null };
      return;
    }
    // only consider inputs/textarea/contentEditable
    if (!isTextInput(active) && !isContentEditable(active)) {
      lastChecked = { el: null, val: null, caret: null };
      return;
    }

    // determine current value & caret
    let val = null;
    let caret = null;
    try {
      if (isTextInput(active)) {
        val = active.value;
        caret = active.selectionStart;
      } else if (isContentEditable(active)) {
        val = active.innerText; // rough textual state
        const sel = window.getSelection();
        caret = sel && sel.rangeCount ? (sel.getRangeAt(0).startOffset) : null;
      }
    } catch (e) {
      val = null;
      caret = null;
    }

    // if changed since last check, try replacement
    if (active !== lastChecked.el || val !== lastChecked.val || caret !== lastChecked.caret) {
      lastChecked = { el: active, val, caret };
      tryReplaceActive();
    }
  }, 180); // every 180ms - light but responsive

  // Paste handling
  document.addEventListener('paste', (e) => {
    setTimeout(() => tryReplaceActive(), 20);
  }, true);

  // Focus change handling
  document.addEventListener('focusin', (e) => {
    // reset cache so polling runs replacement on new field immediately
    lastChecked = { el: null, val: null, caret: null };
  });

  // === Overlay UI (same as before, with small tweaks) ===
  const containerId = 'tm-emoji-overlay-container';
  if (!document.getElementById(containerId)) buildOverlay();

  function buildOverlay() {
    const style = document.createElement('style');
    style.textContent = `
      #${containerId} { position: fixed; right: 12px; top: 12px; z-index: 9999999; font-family: Arial, Helvetica, sans-serif; }
      #${containerId} .tm-btn { background: #1f6feb; color: white; border: none; padding: 8px 10px; border-radius: 6px; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
      #${containerId} .tm-panel { width: 360px; background: white; border-radius: 8px; box-shadow: 0 6px 24px rgba(0,0,0,0.25); margin-top: 8px; overflow: hidden; display: none; font-size: 13px; color: #222; }
      #${containerId} .tm-header { display:flex; align-items:center; justify-content:space-between; padding: 10px 12px; background: #f6f8fa; border-bottom: 1px solid #e6e6e6; }
      #${containerId} .tm-search { padding: 8px 12px; border-bottom: 1px solid #eee; display:flex; gap:8px; align-items:center; }
      #${containerId} input.tm-search-input { flex:1; padding:8px; border:1px solid #ddd; border-radius:6px; }
      #${containerId} .tm-list { max-height: 260px; overflow:auto; padding:8px 12px; }
      #${containerId} .tm-item { display:flex; align-items:center; justify-content:space-between; padding:6px 0; border-bottom:1px dashed #f0f0f0; }
      #${containerId} .tm-item .k { font-weight:600; margin-right:8px; }
      #${containerId} .tm-add { padding:10px 12px; display:flex; gap:8px; border-top:1px solid #eee; background:#fafafa; }
      #${containerId} .tm-small { font-size:12px; color:#666; }
      #${containerId} .tm-toggle { display:flex; align-items:center; gap:8px; }
      #${containerId} .tm-mapping-key { width: 45%; padding:6px; border:1px solid #ddd; border-radius:6px; }
      #${containerId} .tm-mapping-value { width: 35%; padding:6px; border:1px solid #ddd; border-radius:6px; }
      #${containerId} .tm-remove { background:#e55353; color:white; border:none; border-radius:6px; padding:6px 8px; cursor:pointer; }
      #${containerId} .tm-footer { padding:8px 12px; font-size:12px; color:#666; background:#f9fafb; border-top:1px solid #eee; }
    `;
    document.head.appendChild(style);

    const container = document.createElement('div');
    container.id = containerId;

    const btn = document.createElement('button');
    btn.className = 'tm-btn';
    btn.textContent = 'ðŸ˜Š Emojis';
    btn.title = 'Open Emoji Overlay (Ctrl+Shift+E)';
    container.appendChild(btn);

    const panel = document.createElement('div');
    panel.className = 'tm-panel';
    panel.id = containerId + '-panel';

    const header = document.createElement('div');
    header.className = 'tm-header';
    const title = document.createElement('div');
    title.innerHTML = '<strong>Emoji Overlay</strong> <span class="tm-small">Auto-replace ' + (config.requireColons ? '(require :shortcode:)' : '(plain words allowed)') + '</span>';
    header.appendChild(title);
    const closeBtn = document.createElement('button');
    closeBtn.className = 'tm-btn';
    closeBtn.textContent = 'Close';
    header.appendChild(closeBtn);
    panel.appendChild(header);

    const search = document.createElement('div');
    search.className = 'tm-search';
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.placeholder = 'Filter mappings (keyword or emoji)';
    searchInput.className = 'tm-search-input';
    search.appendChild(searchInput);
    const toggleDiv = document.createElement('div');
    toggleDiv.className = 'tm-toggle';
    const enableCheckbox = document.createElement('input');
    enableCheckbox.type = 'checkbox';
    enableCheckbox.checked = !!config.enabled;
    const enableLabel = document.createElement('label');
    enableLabel.appendChild(enableCheckbox);
    enableLabel.append(' Enabled ');
    const colonCheckbox = document.createElement('input');
    colonCheckbox.type = 'checkbox';
    colonCheckbox.checked = !!config.requireColons;
    colonCheckbox.style.marginLeft = '8px';
    const colonLabel = document.createElement('label');
    colonLabel.appendChild(colonCheckbox);
    colonLabel.append(' Require :shortcode: ');
    toggleDiv.appendChild(enableLabel);
    toggleDiv.appendChild(colonLabel);
    search.appendChild(toggleDiv);
    panel.appendChild(search);

    const list = document.createElement('div');
    list.className = 'tm-list';
    panel.appendChild(list);

    const add = document.createElement('div');
    add.className = 'tm-add';
    const keyInput = document.createElement('input');
    keyInput.placeholder = 'keyword (e.g. smile)';
    keyInput.className = 'tm-mapping-key';
    const valInput = document.createElement('input');
    valInput.placeholder = 'emoji (e.g. ðŸ˜Š)';
    valInput.className = 'tm-mapping-value';
    const addBtn = document.createElement('button');
    addBtn.className = 'tm-btn';
    addBtn.textContent = 'Add';
    add.appendChild(keyInput);
    add.appendChild(valInput);
    add.appendChild(addBtn);
    panel.appendChild(add);

    const footer = document.createElement('div');
    footer.className = 'tm-footer';
    footer.innerHTML = 'Tip: Press Ctrl+Shift+E to open. Edit or remove mappings here. Mappings persist in your browser.';
    panel.appendChild(footer);

    container.appendChild(panel);
    document.body.appendChild(container);

    function renderList(filter) {
      list.innerHTML = '';
      const entries = Object.entries(config.mappings).sort((a, b) => a[0].localeCompare(b[0]));
      for (const [k, v] of entries) {
        if (filter) {
          const f = filter.toLowerCase();
          if (!(k.toLowerCase().includes(f) || (v && v.includes(filter)))) continue;
        }
        const item = document.createElement('div');
        item.className = 'tm-item';
        const left = document.createElement('div');
        left.innerHTML = `<span class="k">${escapeHtml(k)}</span><span class="tm-small">${escapeHtml(v)}</span>`;
        const right = document.createElement('div');
        const remove = document.createElement('button');
        remove.className = 'tm-remove';
        remove.textContent = 'Del';
        remove.addEventListener('click', () => {
          delete config.mappings[k];
          saveConfig(config);
          renderList(searchInput.value.trim());
        });
        right.appendChild(remove);
        item.appendChild(left);
        item.appendChild(right);
        list.appendChild(item);
      }
      if (list.childNodes.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'tm-small';
        empty.textContent = 'No mappings match.';
        list.appendChild(empty);
      }
    }

    renderList();

    btn.addEventListener('click', () => togglePanel(true));
    closeBtn.addEventListener('click', () => togglePanel(false));
    function togglePanel(show) {
      panel.style.display = show ? 'block' : 'none';
    }

    searchInput.addEventListener('input', (e) => renderList(e.target.value.trim()));

    enableCheckbox.addEventListener('change', (e) => {
      config.enabled = e.target.checked;
      saveConfig(config);
      refreshBtnState();
    });
    colonCheckbox.addEventListener('change', (e) => {
      config.requireColons = e.target.checked;
      saveConfig(config);
      title.innerHTML = '<strong>Emoji Overlay</strong> <span class="tm-small">Auto-replace ' + (config.requireColons ? '(require :shortcode:)' : '(plain words allowed)') + '</span>';
    });

    addBtn.addEventListener('click', () => {
      const k = keyInput.value.trim();
      const v = valInput.value.trim();
      if (!k || !v) {
        alert('Provide both keyword and emoji.');
        return;
      }
      const safeKey = canonicalKey(k);
      config.mappings[safeKey] = v;
      saveConfig(config);
      keyInput.value = '';
      valInput.value = '';
      renderList(searchInput.value.trim());
    });

    // Keyboard shortcut Ctrl+Shift+E
    document.addEventListener('keydown', (ev) => {
      if (ev.ctrlKey && ev.shiftKey && ev.code === 'KeyE') {
        ev.preventDefault();
        panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
      }
    });

    function refreshBtnState() {
      if (config.enabled) btn.style.background = '#1f6feb';
      else btn.style.background = '#9aa4b2';
    }
    refreshBtnState();
  }

  // small helper
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
  }

  console.info('Emoji Overlay (live) loaded. Press Ctrl+Shift+E to open overlay.');
})();
